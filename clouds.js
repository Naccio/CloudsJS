/**
 * A cloud managed by this module
 * @typedef {Object} Cloud
 * @property {number} x - The cloud's center on the horizontal axis.
 * @property {number} y - The cloud's center on the vertical axis.
 * @property {HTMLCanvasElement} canvas - An HTML canvas element depiting the pre-rendered cloud.
 */

/**
 * Create a new cloud and pre-render it on a new canvas.
 * @param {number} x - The cloud's center on the horizontal axis.
 * @param {number} y - The cloud's center on the vertical axis.
 * @param {number} w - The cloud's width.
 * @param {number} h - The cloud's height.
 * @param {number} circles - The number of circles used to generate the cloud.
 * @param {Object} color - The cloud's color.
 * @param {number} color.r - The color's red value.
 * @param {number} color.g - The color's green value.
 * @param {number} color.b - The color's blue value.
 * @param {number} color.a - The color's alpha value.
 * @returns {Cloud} A new cloud built according to the given parameters. 
 */
export function createCloud(x, y, w, h, circles, color) {
	const halfW = w / 2;
	const halfH = h / 2;
	const canvas = document.createElement("canvas");
	const context = canvas.getContext("2d");

	canvas.width = w;
	canvas.height = h;

	for (let i = 0; i < circles; i++) {
		const scale = Math.random() * 0.75,
			direction = Math.random() * Math.PI * 2,
			xShift = Math.cos(direction) * scale * halfW,
			yShift = Math.sin(direction) * scale * halfH,
			circleX = halfW + xShift,
			circleY = halfH + yShift,
			maxRadius = Math.min(halfW - Math.abs(xShift), halfH - Math.abs(yShift)),
			circleRadius = maxRadius * getRandom(0.5, 1);

		const gradient = context.createRadialGradient(circleX, circleY, 0, circleX, circleY, circleRadius);
		const gradientColor = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", ";

		gradient.addColorStop(0, gradientColor + color.a + ")");
		gradient.addColorStop(1, gradientColor + "0)");

		context.fillStyle = gradient;

		context.beginPath();
		context.arc(circleX, circleY, circleRadius, 0, Math.PI * 2, true);
		context.fill();
		// context.stroke();
	}

	const cloud = {
		x,
		y,
		w,
		h,
		canvas
	};

	return cloud;
}

/**
 * Draw a cloud on a 2D rendering context.
 * @param {Cloud} cloud - A cloud, possibly generated by the {@link createCloud} function.
 * @param {CanvasRenderingContext2D} context - The 2D rendering context where the cloud will be painted.
 */
export function drawCloud(cloud, context) {
	context.drawImage(cloud.canvas, cloud.x - cloud.w / 2, cloud.y - cloud.h / 2);
	// context.beginPath();
	// context.rect(cloud.x - cloud.w / 2, cloud.y - cloud.h / 2, cloud.w, cloud.h);
	// context.stroke();
}

/**
 * Manages cloud creation and animation on an HTML canvas.
 */
export default class Clouds {
	#clouds = [];
	#wind = 0;
	#sky = "rgba(0,0,0,0)";
	#running = false;
	#lastUpdate;
	#context;
	#animationId;

	/**
	 * Create an instance of this class.
	 * @param {HTMLCanvasElement} canvas - The canvas element managed by the created instance. 
	 */
	constructor(canvas) {
		if (!(canvas instanceof HTMLCanvasElement)) {
			throw "Invalid HTML canvas.";
		}

		this.#context = canvas.getContext('2d');
	}

	/**
	 * Pause the clouds animation.
	 */
	pause() {
		if (!this.#running) {
			return;
		}

		this.#running = false;
		cancelAnimationFrame(this.#animationId);
	}

	/**
	 * Run the cloud animation.
	 */
	run() {
		if (this.#running) {
			return;
		}

		this.#running = true;
		this.#aniamtionFrame();
	}

	/**
	 * Set the direction of the wind, that will be used to move the clouds.
	 * Note that the y axis on a canvas is inverted, thus half of pi is downwards.
	 * @param {number} w - The wind direction in radians.
	 */
	setWindDirection(w) {
		this.#wind = w;
	}

	/**
	 * Set the sky color.
	 * This will effectively paint a rectangle over the whole canvas before rendering the clouds.
	 * @param {string} c - A string representing a CSS color.
	 */
	setSkyColor(c) {
		this.#sky = c;
	}

	/**
	 * Add a new cloud to the canvas managed by this instance.
	 * @param {number} x - The cloud's center on the horizontal axis.
	 * @param {number} y - The cloud's center on the vertical axis.
	 * @param {number} w - The cloud's width.
	 * @param {number} h - The cloud's height.
	 * @param {number} circles - The number of circles used to generate the cloud.
	 * @param {Object} color - The cloud's color.
	 * @param {number} color.r - The color's red value.
	 * @param {number} color.g - The color's green value.
	 * @param {number} color.b - The color's blue value.
	 * @param {number} color.a - The color's alpha value.
	 * @param {number} speed - The cloud's speed expressed in pixels per second.
	 */
	add(x, y, w, h, circles, color, speed) {
		const cloud = createCloud(x, y, w, h, circles, color);

		cloud.speed = speed;
		this.#clouds.push(cloud);
	}

	/**
	 * Manually trigger rendering on the canvas managed by this instance.
	 * If the animation is running, this will be done automatically.
	 */
	draw() {
		const w = this.#context.canvas.width,
			h = this.#context.canvas.height;

		this.#context.clearRect(0, 0, w, h);
		this.#context.fillStyle = this.#sky;
		this.#context.fillRect(0, 0, w, h);

		this.#clouds.forEach(cloud => drawCloud(cloud, this.#context));
	}

	#animate(timestamp) {
		const elapsed = timestamp - this.#lastUpdate;

		if (this.#lastUpdate !== undefined && elapsed < 250) {
			this.#update(elapsed);
			this.draw();
		}

		this.#lastUpdate = timestamp;
		this.#aniamtionFrame();
	}

	#aniamtionFrame() {
		this.#animationId = requestAnimationFrame((t) => this.#animate(t));
	}

	#update(elapsed) {
		this.#clouds.forEach(cloud => {
			const
				context = this.#context,
				wind = this.#wind,
				delta = cloud.speed * elapsed / 1000,
				dx = Math.cos(wind) * delta,
				dy = Math.sin(wind) * delta,
				halfW = cloud.w,
				halfH = cloud.h,
				w = context.canvas.width,
				h = context.canvas.height;

			cloud.x += dx;
			if (dx > 0 && cloud.x - halfW > w) {
				cloud.x = 0 - halfW;
			} else if (dx < 0 && cloud.x + halfW < 0) {
				cloud.x = w + halfW;
			}
			cloud.y += dy;
			if (dy > 0 && cloud.y - halfH > h) {
				cloud.y = 0 - halfH;
			} else if (dy < 0 && cloud.y + halfH < 0) {
				cloud.y = h + halfH;
			}
		});
	}
}

function getRandom(min, max) {
	return Math.random() * (max - min) + min;
}