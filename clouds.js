/**
 * Clouds.js: a module for creating and animating clouds.
 * @module clouds
 */

/**
 * A cloud managed by this module
 * @typedef {Object} Cloud
 * @property {number} x - The cloud's center on the horizontal axis.
 * @property {number} y - The cloud's center on the vertical axis.
 * @property {number} w - The cloud's width.
 * @property {number} h - The cloud's height.
 * @property {HTMLCanvasElement} canvas - An HTML canvas element depicting the pre-rendered cloud.
 */

/**
 * A color used to render a cloud.
 * @typedef {Object} Color
 * @property {number} r - The color's red value, between 0 and 255.
 * @property {number} g - The color's green value, between 0 and 255.
 * @property {number} b - The color's blue value, between 0 and 255.
 * @property {number} a - The color's alpha value, between 0 and 1.
 */

/**
 * Create a new cloud and pre-render it on a new canvas.
 * @param {number} x - The cloud's center on the horizontal axis.
 * @param {number} y - The cloud's center on the vertical axis.
 * @param {number} w - The cloud's width in pixels.
 * @param {number} h - The cloud's height in pixels.
 * @param {number} circles - The number of circles used to generate the cloud.
 * @param {Color} color - The cloud's color.
 * @returns {Cloud} A new cloud built according to the given parameters. 
 */
export function createCloud(x, y, w, h, circles, color) {
	const halfW = w / 2,
		halfH = h / 2,
		twoPi = Math.PI * 2,
		{ r, g, b, a } = color,
		canvas = document.createElement("canvas"),
		context = canvas.getContext("2d");

	canvas.width = w;
	canvas.height = h;

	for (let i = 0; i < circles; i++) {
		const scale = getRandom(0, .75),
			direction = getRandom(0, twoPi),
			// de La Hire
			xShift = Math.cos(direction) * halfW * scale,
			yShift = Math.sin(direction) * halfH * scale,
			circleX = halfW + xShift,
			circleY = halfH + yShift,
			maxRadius = Math.min(halfW - Math.abs(xShift), halfH - Math.abs(yShift)),
			circleRadius = maxRadius * getRandom(.5, 1),
			gradient = context.createRadialGradient(circleX, circleY, 0, circleX, circleY, circleRadius);

		gradient.addColorStop(0, `rgba(${r},${g},${b},${a})`);
		gradient.addColorStop(1, `rgba(${r},${g},${b},0)`);

		context.fillStyle = gradient;

		context.beginPath();
		context.arc(circleX, circleY, circleRadius, 0, twoPi, true);
		context.fill();
		// context.stroke();
	}

	const cloud = {
		x,
		y,
		w,
		h,
		canvas
	};

	return cloud;
}

/**
 * Draw a cloud on a 2D rendering context.
 * @param {Cloud} cloud - A cloud, possibly generated by the {@link createCloud} function.
 * @param {CanvasRenderingContext2D} context - The 2D rendering context where the cloud will be painted.
 */
export function drawCloud(cloud, context) {
	context.drawImage(cloud.canvas, cloud.x - cloud.w / 2, cloud.y - cloud.h / 2);
	// context.beginPath();
	// context.ellipse(cloud.x, cloud.y, cloud.w / 2, cloud.h / 2, 0, 0, 2 * Math.PI);
	// context.stroke();
}

/**
 * Manages cloud creation and animation on an HTML canvas.
 */
export default class Clouds {
	#clouds = [];
	#wind = 0;
	#sky = "rgba(0,0,0,0)";
	#running = false;
	#lastUpdate;
	#idleThreshold = 250;
	#context;
	#animationId;

	/**
	 * Create an instance of this class.
	 * @param {HTMLCanvasElement} canvas - The canvas element managed by the created instance. 
	 */
	constructor(canvas) {
		if (!(canvas instanceof HTMLCanvasElement)) {
			throw "Invalid HTML canvas.";
		}

		this.#context = canvas.getContext('2d');
	}

	/**
	 * Pause the clouds animation.
	 */
	pause() {
		if (!this.#running) {
			return;
		}

		this.#running = false;
		cancelAnimationFrame(this.#animationId);
	}

	/**
	 * Run the cloud animation.
	 */
	run() {
		if (this.#running) {
			return;
		}

		this.#running = true;
		this.#animationFrame();
	}

	/**
	 * Set the direction of the wind, that will be used to move the clouds.
	 * Note that the y axis on a canvas is inverted, thus half of pi is downwards.
	 * @param {number} w - The wind direction in radians.
	 */
	setWindDirection(w) {
		this.#wind = w;
	}

	/**
	 * Set the sky color.
	 * This will effectively paint a rectangle over the whole canvas before rendering the clouds.
	 * @param {string} c - A string representing a CSS color.
	 */
	setSkyColor(c) {
		this.#sky = c;
	}

	/**
	 * Add a new cloud to the canvas managed by this instance.
	 * @param {number} x - The cloud's center on the horizontal axis.
	 * @param {number} y - The cloud's center on the vertical axis.
	 * @param {number} w - The cloud's width in pixels.
	 * @param {number} h - The cloud's height in pixels.
	 * @param {number} circles - The number of circles used to generate the cloud.
	 * @param {Color} color - The cloud's color.
	 * @param {number} speed - The cloud's speed in pixels per second.
	 */
	add(x, y, w, h, circles, color, speed) {
		const cloud = createCloud(x, y, w, h, circles, color);

		cloud.speed = speed;
		this.#clouds.push(cloud);
	}

	/**
	 * Manually trigger rendering on the canvas managed by this instance.
	 * If the animation is running, this will be done automatically.
	 */
	draw() {
		const w = this.#context.canvas.width,
			h = this.#context.canvas.height;

		this.#context.clearRect(0, 0, w, h);
		this.#context.fillStyle = this.#sky;
		this.#context.fillRect(0, 0, w, h);

		this.#clouds.forEach(cloud => drawCloud(cloud, this.#context));
	}

	#animate(timestamp) {
		const elapsed = timestamp - this.#lastUpdate;

		if (this.#lastUpdate !== undefined && elapsed < this.#idleThreshold) {
			this.#update(elapsed);
			this.draw();
		}

		this.#lastUpdate = timestamp;
		this.#animationFrame();
	}

	#animationFrame() {
		this.#animationId = requestAnimationFrame((t) => this.#animate(t));
	}

	#update(elapsed) {
		this.#clouds.forEach(cloud => {
			const
				context = this.#context,
				wind = this.#wind,
				delta = cloud.speed * elapsed / 1000,
				dx = Math.cos(wind) * delta,
				dy = Math.sin(wind) * delta,
				halfW = cloud.w,
				halfH = cloud.h,
				w = context.canvas.width,
				h = context.canvas.height;

			cloud.x += dx;
			if (dx > 0 && cloud.x - halfW > w) {
				cloud.x = 0 - halfW;
			} else if (dx < 0 && cloud.x + halfW < 0) {
				cloud.x = w + halfW;
			}
			cloud.y += dy;
			if (dy > 0 && cloud.y - halfH > h) {
				cloud.y = 0 - halfH;
			} else if (dy < 0 && cloud.y + halfH < 0) {
				cloud.y = h + halfH;
			}
		});
	}
}

function getRandom(min, max) {
	return Math.random() * (max - min) + min;
}